# 개발 공부
## CDN (Contents Delivery Network)

 - 지리,물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공할 수 있는 기술
 - 느린 응답속도, 다운로딩 타임을 극복하기 위한 기술

일단은 어떤 장비나 제품이 아닌 **기술** 이다. 일련의 모델? 이라고 봐도 될까.

### CDN 장점
1. 웹사이트 로딩 속도 개선
2. 인터넷 회선 비용 절감
3. 컨텐츠 제공의 안정성
4. 웹사이트 보안 개선

1, 3번은 어렴풋이 예상이 간다. 2, 4는 그에 따라 파생되는 장점인 것 같은데, 4번은 구체적으로 확 와닿지는 않는다.

### CDN의 작동 원리
요는 중간에 캐시 서버를 두어 메인(origin) 서버의 트래픽 부담을 줄이는게 목적.
1. 최초 요청은 서버로 부터 컨텐츠를 가져와 고객에게 전송하며 동시에 CDN캐싱장비에 저장한다.
2. 두번째 이후 모든 요청은 CDN 업체에서 지정하는 해당 컨텐츠 만료 시점까지 CDN캐싱장비에 저장된 컨텐츠를 전송한다.
3. 자주 사용하는 페이지에 한해서 CDN장비에서 캐싱이 되며, 해당 컨텐츠 호출이 없을 경우 주기적으로 삭제된다.
4. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾아 엔드유저에게 응답을 전송한다.
5. 콘텐츠를 사용할 수 없거나 콘텐츠가 오래된 경우, CDN은 서버에 대한 요청을 프록시로 작동하여 향후 요청에 대해 응답할 수 있도록 새로운 콘텐츠를 저장한다.


### CDN의 필요기술
#### 1. Load Balance**
   - 사용자에게 콘텐츠 전송 요청(Delivery Request)을 받았을 때, 최적의 네트워크 환경을 찾아 연결하는 기술, GSLB(Global Server Load Balancing)이라고도 한다.
   - 물리적으로 가장 가깝거나 여유 트래픽이 남아 있는 곳으로 접속을 유도하는 기술이다.


> **GSLB(Global server Load Balancing)**
> DNS(도메인 이름을 IP주소로 변환하는 서비스) 서비스의 발전된 형태라고 할 수 있다.

##### DNS와 GSLB 차이점
- **health check**
  - DNS: 서버의 상태를 알 수 없어서 서비스를 실패하는 유저도 생길 수 있다.
  - GSLB: 서버의 상태를 모니터링(주기적으로 health check를 수행) 하고 실패한 서버의 IP는 응답에서 제외 하므로, DNS보다 훨씬 강력한 기능을 제공한다.
- **로드 밸런싱**
  - DNS : Round Robin 방식을 사용, 정교한 로드 밸런싱이 힘들다.
  - GSLB : 서버의 로드를 모니터링 하기 때문에 로드가 적은 서버의 IP를 반환하는 식으로 정교한 로드밸런싱을 할 수 있다.
- **레이턴시 기반 서비스**
  - DNS: Round Robin 방식을 사용하여 유저는 네트워크상에서 멀리 떨어진 위치의 서버로 연결 할 수도 있다.
  - GSLB: 각 지역별로 서버에 대한 레이턴시(latency) 정보를 가지고 있기 때문에 유저가 접근을 하면, 유저의 지역으로 부터 가까운(더 작은 레이턴시를 가지는) 서버로 연결을 한다.
- **위치기반 서비스**
  - DNS: 유저는 Round Robin하게 서버로 연결된다.
  - GSLB: 유저의 지역정보를 기반으로, 해당 지역을 서비스하는 서버로 연결 할 수 있다.
  - > **라운드 로빈 스케줄링(Round Robin Scheduling, RR)**
    > 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum)로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘
#### 2. 컨텐츠를 배포하는 기술
컨텐츠의 삭제나 수정이 일어났을 때 이를 관리할 수 있는 기술이 필요하다.

#### 3. CDN의 트래픽을 감지하는 기술
- 통계자료를 고객에게 제공하기 위해 필요하다.
- 트래픽을 분산하기 위해서 필요하다

### 캐싱 방식
1. **Static Caching**
   - Origin Server에 있는 Content를 운영자가 미리 Cache Server에 복사
   - 미리 복사해 두기 때문에 사용자가 Cache Server에 Content를 요청시 무조건 Cache Server에 있다.
   - 대부분의 국내 CDN에서 이 방식을 사용( ex. NCSOFT 게임파일 다운로드 등)
2. **Dynamic Caching**
   - Origin Server에 있는 Content를 운영자가 미리 Cache Server에 복사하지 않음
   - 사용자가 Content를 요청시 해당 Content가 없는 경우 Origin Server로 부터 다운로드 받아 전달한다. (Content가 있는 경우는 캐싱된 Content 사용자에게 전달.)
   - 각각의 Content는 일정 시간이후 Cache Server에서 삭제될 수도 있다. (계속 가지고 있을 수도 있음)


### Reference
- https://goddaehee.tistory.com/173
- https://docs.ncloud.com/ko/networking/networking-8-1.html

## 트랜잭션 격리
동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것.


#### READ UNCOMMITTED
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level
- 트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
- 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted 혹은 - Dirty) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.
- 데이터베이스의 일관성을 유지할 수 없다.

#### READ COMMITTED
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 Level
- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.
- Commit이 이루어진 트랜잭션만 조회할 수 있다.
- 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다.
- SQL Server가 Default로 사용하는 Level

#### REPEATABLE READ
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
- 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.
- 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다.


#### SERIALIZABLE
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
- 완벽한 읽기 일관성 모드를 제공한다.
- 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.

### 낮은 단계의 트랜잭션 격리 수준(Isolation Level) 이용시 발생하는 현상

1. Dirty Read
커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
어떤 트랜잭션에서 아직 실행이 끝난지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 되는 경우
2. Non-Repeatable Read
한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 두 쿼리의 결과가 상이하게 나타나는 비 일관성 현상
한 트랜잭션이 수행중일 때 다른 트랜잭션이 값을 수정 또는 삭제함으로써 나타난다.
3. Phantom Read
한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
한 트랜잭션이 수행중일 때 다른 트랜잭션이 새로운 레코드가 삽입함으로써 나타난다.


### Reference
- https://lng1982.tistory.com/287
- https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation
- https://notemusic.tistory.com/49


## 엘라스틱 서치
- 검색 엔진
  - 검색 서비스 (X)
  - 검색 시스템/프로그램(O)
- 현재 가지고 있는 데이터 중에서 특정한 데이터를 검색할 수 있는 기능을 제공

### 검색 서비스의 요소
1. 수집기
주로 웹 크롤러라고 불리는 수집기는 여러 사이트를 돌아다니며 그 사이트가 가진 내용들을 특정한 저장소(주로 DB)에 저장한다.
2. 저장소(DB)
수집기가 저장한 데이터를 저장할 수 있는 저장소가 당연히 필요하다.
3. 색인기
수집한 데이터를 색인이라는 과정을 거쳐 검색하기 용이한 데이터로 만들어주는 역할을 한다.
검색 엔진의 색인기의 경우 주로 역색인이라는 색인 방법을 사용한다.
4. 검색기
색인된 단어를 검색할 수 있는 검색기(검색 엔진)가 필요하다. 검색기는 검색순위 알고리즘을 가지고 있어서 더욱 적합한 검색결과라고 생각할수록 그 결과를 상위에 표시한다.
검색 결과를 제공할 웹 UI
보통 웹개발자들이 만든다. HTML, CSS, JS등의 기술이 필요

이 중에서 엘라스틱서치는 그 자체로 2, 3, 4의 기능을 제공한다.

### 색인(Index)과 역색인(Inverted-Index)
어떠한 키워드가 주어졌을때에, 어떠한 문서에서 나타났는지를 알려주는 자료구조

쉽게 말해서 색인이 문서들에서 키워드를 뽑아내는 과정이라면 역색인은 어떠한 키워드에대해 요청(찾아달라고)이 들어왔을때 그 뽑아낸 키워드들을 바탕으로 그 키워드가 포함된 문서를 찾아내는 것

### 검색 엔진이 필요한 이유
1. 관계형 데이터베이스는 단순 텍스트매칭에 대한 검색만을 제공
2. 텍스트를 여러 단어로 변형하거나 텍스트의 특질을 이용한 동의어나 유의어를 활용한 검색이 가능
3. 엘라스틱서치에서는 형태소 분석을 통한 자연어 처리가 가능
4. 역색인 지원으로 매우 빠른 검색이 가능

### 장점
- 데이터베이스 대용으로 사용 가능
  - NoSQL 데이터베이스처럼 사용이 가능합니다. 또한 분류가 가능하고 분산 처리를 통해 거의 실시간(NRT)에 데이터 검색이 가능합니다.
- 대량의 비정형 데이터 보관 및 검색 가능
  - 기존 데이터베이스로 처리하기 어려운 대량의 비정형 데이터 검색이 가능하며, 전문 검색(Full-Text Search)과 구조 검색 모두를 지원합니다. 기본적으로는 검색엔진이지만 MongoDB나 Hbase처럼 대용량 스토리지로 사용도 가능합니다.
- 오픈소스 검색엔진
  - 아파치 루씬(Lucene)기반 오픈소스 검색엔진으로 무료로 사용 가능하며, 많은 컨트리뷰터들이 실시간으로 소스를 수정해주기 때문에 버그가 발생하면 빠르게 해결됩니다.
- 전문 검색(Full-text Search)
  - 내용 전체를 색인하여 특정 단어가 포함된 문서를 검색하는 것이 가능합니다.
- 통계 분석
  - 비정형 로그 데이터를 수집하고 한 곳에 모아서 통계 분석이 가능하다. 키바나를 이용하면 시각화 또한 가능합니다.
- 스키마리스(Schemaless)
  - 기존의 관계형 데이터베이스는 스키마라는 구조에 따라 데이터를 적합한 형태로 변경하여 저장 관리하지만 엘라스틱서치는 비정형의 다양한 형태의 문서도 자동으로 색인, 검색이 가능합니다.
- RESTful API
  - RESTful API를 사용하여 HTTP통신 기반으로 요청을 받아 JSON 형식으로 응답한다는 것은 다양한 플랫폼에서 응용 가능하다는 것을 의미합니다.
- 멀티 테넌시(Multi-tenancy)
  - 엘라스틱서치에서 인덱스는 관계형 DB의 데이터베이스와 같은 개념임에도 불구하고, 서로 다른 인덱스에서도 검색할 필드명만 같으면 여러 개의 인덱스를 한번에 조회할 수 있습니다.
- Document-Oriented
  - 여러 계층의 데이터를 JSON 형식의 구조화된 문서로 인덱스에 저장 가능합니다. 계층 구조로 문서도 한 번의 쿼리로 쉽게 조회 가능합니다
- 역색인(Inverted-Index)
  - (위의 내용 참고)
- 확장성과 가용성
  - 매우 많은 데이터가 존재할 때, 분산 시스템 구성으로 병렬적인 처리가 가능합니다. 분산 환경에서는 데이터가 샤드(Shard)라는 단위로 나누어 제공됩니다. 인덱스 생성 시마다 샤드의 수 조정이 가능합니다. 데이터의 종류와 성격에 따라 데이터를 분산하여 빠르게 처리 가능합니다.


### 단점
- '실시간(Real Time)' 처리는 불가능하다.
  - 엘라스틱서치의 데이터 색인의 특징 때문에 엘라스틱서치의 색인된 데이터는 1초 뒤에나 검색이 가능합니다. 왜냐하면 색인된 데이터가 내부적으로 커밋(Commit)과 플러시(Flush)와 같은 과정을 거치기 때문입니다. 그래서 엘라스틱서치 공식 홈페이지에서도 NRT(Near Real Time)라는 표현을 씁니다.
- 트랜잭션(Transaction) 롤백(Rollback) 등의 기능을 제공하지 않는다.
  - 분산 시스템 구성의 특징 때문에, 시스템적으로 비용 소모가 큰 롤백, 트랜잭션을 지원하지 않습니다. 그래서 데이터 관리에 유의해야 합니다.
- 진정한 의미의 업데이트(Update)를 지원하지 않는다.
  - 엘라스틱서치에는 물론 업데이트 명령이 있습니다만, 실제로는 데이터를 삭제했다가 다시 만드는 과정으로 업데이트됩니다. 이러한 특성은 나중에 불변성(Immutable)이라는 이점을 제공하기도 합니다.

### Reference
- https://velog.io/@jakeseo_me/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-1-%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EB%8A%94-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%9D%B4%EB%8B%A4
- https://velog.io/@jakeseo_me/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-2-DB%EB%A7%8C-%EC%9E%88%EC%9C%BC%EB%A9%B4-%EB%90%98%EB%8A%94%EB%8D%B0-%EC%99%9C-%EA%B5%B3%EC%9D%B4-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84
- https://giyatto.tistory.com/2
- https://needjarvis.tistory.com/345


## 카프카
- 메시지 큐
  - 메시지 지향 미들웨어(Message Oriented Middleware: MOM)은 비동기 메시지를 사용하는 다른 응용프로그램 사이의 데이터 송수신을 의미하는데 MOM을 구현한 시스템

분산형 스트리밍 플랫폼(A distributed streaming platform)이다. LinkedIn에서 여러 구직 및 채용 정보들을 한곳에서 처리(발행/구독)할 수 있는 플래폼으로 개발이 시작 되었다고 한다.

(발행/구독: pub-sub은 메시지를 특정 수신자에게 직접적으로 보내주는 시스템이 아니고, 메시지를 받기를 원하는 사람이 해당 토픽(topic)을 구독함으로써 메시지를 읽어 올 수 있다.)

### 특징

대용량 실시간 로그처리에 특화되어 설계된 메시징 시스템으로 TPS가 매우 우수하고,

메시지를 메모리에 저장하는 기존 메시징 시스템과는 달리 파일에 저장을 하는데 그로 인해 카프카를 재시작해도 메시지 유실 우려가 감소된다.

기본 메시징 시스템(rabbitMQ, ActiveMQ)에서는 브로커(Broker)가 컨슈머(consumer)에게 메시지를 push해 주는 방식인데, 카프카는 컨슈머(Consumer)가 브로커(Broker)로부터 메시지를 직접 가져가는 PULL 방식으로 동작하기 때문에 컨슈머는 자신의 처리 능력만큼의 메시지만 가져와 최적의 성능을 낼 수 있다. 대용량처리에 특화 되었다는 것은 아마도 이러한 구조로 설계가 되어 가능하게 된게 아닌가 싶다.

### 구성 요소

- topic, partition, offset
- producer, consumer, consumer group
- broker, zookeeper
- replication

#### Topic, Partition
카프카에 저장되는 메시지는 topic으로 분류되고, topic은 여러개의 patition으로 나눠질수 있다. partition안에는 message의 상대적 위치를 내타내는 offset이 있는데 이 offet정보를 이용해 이전에 가져간 메시지의 위치 정보를 알 수 있고 동시에 들어오는 많은 데이터를 여러개의 파티션에 나누어 저장하기 때문에 병렬로 빠르게 처리할 수 있다.

#### Consumer Group 
Producer에서 생산(Write)한 메시지는 여러개의 파티션에 저장을 하는데, 그렇다면 소비하는(Consumer)하는 쪽에서도 여러 소비자가 메시지를 읽어가는것이 훨씬 효율적일 것이다. 하나의 목표를 위해 소비를 하는 그룹, 즉 하나의 토픽을 읽어가기 위한 Counsumer들을 Consumer Group라고 한다.

하지만 이 Consumer Group에는 한가지 룰이 있다. Topic의 파티션은 그 Consumer Group과 1:n 매칭. 즉, 자신이 읽고 있는 파티션에는 같은 그룹내 다른 컨슈머가 읽을 수 없다.

#### Broker, Zookeeper
broker는 카프카 서버를 칭한다. 동일한 노드내에서 여러개의 broker서버를 띄울 수 있고, Zookeeper는 이러한 분산 메시지큐의 정보를 관리해주는 역할을 한다. 카프카를 띄우기 위해서는 반드시 주키퍼가 실행되어야 한다.

#### Replication
카프카에서는 replication 수를 임의로 지정하여 topic를 만들 수 있다. replication-factor에 지정하는데 만약 3으로 하면 replication 수가 3이 된다.

replication을 좀더 자세히 들여다보면, 복제요소중 대표인 leader, 그외 요소인 follower로 나누어진다. topic으로 통하는 모든 데이터의 read/write는 오직 leader에서 이루어지고 follower는 leader와 sync를 유지함으로써 leader에 문제가 생겼을 경우 follower들 중 하나가 leader역할을 하게 되는 것이다.

### Reference
- https://team-platform.tistory.com/11
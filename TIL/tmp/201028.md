# 알고리즘
## 기출 문제 2

역시 푼 시간은 길지만, 어떻게 풀었냐고 설명을 하라고 하면 엄청나게 간단 명료해진다. 고민한 시간이 무색해질 정도로...

### 핵심 로직
핵심 로직은 이렇다. 
> 좌우로 막힌 두개의 블록 중 최소 높이를 계산

**구간**(두 블록의 인덱스)과 **높이(값)** 를 알면 나머지는 문제대로 풀면 된다. 이걸 어떻게 구할지는

### 시행착오
이 값들을 구하기 위해 별의 별 생각을 다했다.

어떻게든 순회 한번으로 해결하고 싶어서 최댓값, 두번째 최댓값, 최솟값을 기록해둔채로 양쪽 벽을 판별하고 높이를 알아내려고 시도했지만 복잡하기도 하고 생각해낸 로직 자체가 부실해서 중간에 그만뒀다. 

시간복잡도 효율을 포기하고 단순하게 각 인덱스마다 좌우로 순회하면서 양쪽 벽을 판별하고 계산하고 싶었지만 이건 너무 비효율적이다. (생각만했다)

### 풀이
그런 와중에 **현재 순회 중 구간의 액체의 최대 높이**는 **이전에 만난 최댓값**임을 깨달았다. 하지만 이건 배열 내 최댓값을 만난 이후에는 의미가 없어졌다. 하지만 이걸 뒤로 한번 더 순회하면 해결 할 수 있는 문제였다! 이렇게 해도 $O(n)$이다.

로직 방면이 아닌 구현쪽에서 아쉬운 부분이 있었는데, 반복문 하나로 0~n, n~0을 순회하는 것에 실패했다. 그것만 빼고 거의 구현이 같은데 똑같은 코드를 두번 써야한다는게 굉장히 불편했다.

### 리뷰

분류를 뭐라고 해야할까? 결과적으론 사실상 배열을 순회한게 전부이긴한데... 

이전에 풀었던 '기출문제1'과는 달리, 문제를 현실의 로직에 따라 그대로 구현하지 못하는 문제이다. 따지고 보면 물리(중력, 유체역학 등)의 영역이기 때문.

그래서 이런 문제는 조금 더 수학적인, 혹은 논리적 능력이 필요한 것 같다. 


# 개발 공부
## 대칭키 & 공개키(비대칭키)
### 암호화
암호화는 알고리즘을 이용하여 누구든 읽어볼 수 있는 평문으로 저장된 정보를 암호 인증키를 가진 사람만이 볼 수 있도록 암호문으로 변환하는 것.

 암호화 체계는 복호화 키와 암호화 키의 일치 여부에 따라 크게 대칭키 암호화 기법, 비대칭형 공개키 암호화 기법으로 나뉘며 그 외에도 일방향 암호화 기법인 해시 암호화 기법이 있다.

### 대칭키(비밀키)

대칭키 암호 알고리즘을 사용하여 전송하고자 하는 평문을 암호화하고 복호화하는데 동일한 키를 사용하는 방식 
- 공개키(비대칭키) 암호화 방식에 비해 빠른 처리속도를 제공
- 암호키의 길이가 공개키 암호화 방식보다 상대적으로 작아서 일반적인 정보의 기밀성을 보장하기 위한 용도로 사용
- 정보 교환 당사자가 동일한 키를 공유해야 하므로 여러 사람과의 정보 교환 시 많은 키를 유지 및 관리해야함

### 공개키(비대칭키)
공개키 암호 알고리즘을 사용하여 암호화하며 공개키와 개인키의 키 쌍이 존재하여 평문을 암·복호화 하는데 서로 다른 키를 사용하는 방식으로 비대칭키 암호화 방식이라고도 불린다.
- 데이터 암호화 속도가 대칭키 암호화 방식에 비해 느림
-  때문에 일반적으로 대칭키 암호화 방식의 키 분배나 전자서명 또는 카드번호와 같은 작은 크기의 데이터 암호화에 많이 사용되고 있다. 

#### 전자서명
**개인키로 암호화를 하는 경우**, 
- 개인키의 소유자가 개인키로 데이터를 암호화하고 공개키와 함께 전달
- 이 과정에서 공개키와 데이터를 획득한 사람은 송신자의 공개키로 복호화가 가능
- 복호화된 데이터가 공개키로 복호화 된다는 것은 공개키와 쌍을 이루는 개인키에 의하여 암호화되었다는 것을 의미 
- 즉, 데이터의 제공자의 신원 확인이 보장된다는 것. 이 방법으로 공인인증체계의 기본바탕인 전자서명. 개인키 암호화를 전자서명이라 부른다.

### Reference 
- https://gaeko-security-hack.tistory.com/123
- https://saysecurity.tistory.com/16
- https://academy.binance.com/ko/articles/symmetric-vs-asymmetric-encryption





## HTTP / HTTPS
### HTTP
- 인터넷 상에서 **텍스트 정보**를 주고 받기위한 프로토콜
- 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜
- 암호화되지 않은 방법으로 데이터를 전송한다. (악의적인 감청, 데이터 변조의 가능성)

### HTTPS (Hypertext Transfer Protocol **Over Secure Socket Layer**)
- 보안이 강화된 HTTP
- 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다
- HTTPS는 HTTP의 하부에 SSL과 같은 보안계층을 제공함으로써 동작한다

### SSL (Secure Socket Layer)
- HTTPS에서 보안을 위해 사용되는 프로토콜
  - 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS(Transport Layer Security Protocol)라는 이름으로 바뀌었다
  - TLS 1.0은 SSL 3.0을 계승했지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용된다
- Certificate Authority(CA)라 불리는 서드 파티로부터 서버와 클라이언트의 인증을 하는데 사용된다

### SSL 인증서
- SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서
- 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달하게 된다
- 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한다

### 통신 과정
#### 서버(웹)에서 HTTPS 통신 방식을 제공하기 위한 과정
- 1: HTTPS 통신 방식을 위해 CA(Certificate Authority)로부터 인증서를 구입하게 된다.이 때 웹은 서비스의  도메인과 서버 공개키 정보를 제출한다
  - (CA는 민간기업이지만 아무나 운영할 수 없고 신뢰성이 검증된 기업만 CA를 운영할 수 있음)
- 2: CA는 서비스의 정보를 비공개키를 이용하여 암호화한다
- 3, 4: 웹은 CA로부터 암호화된 SSL 인증서를 제공받는다

#### 브라우저가 HTTPS 통신을 하는 과정
- 5: 브라우저는 서버와 데이터를 주고 받기 전, 가장 먼저 웹으로부터 SSL 인증서를 받게  된다
   - (브라우저는 내부적으로 CA의 리스트를 파악하고 있으며 CA의  공개키에 대한 정보도 대부분 알고 있다)
- 6 브라우저는 웹 서버로부터 받은 인증서를 CA의 공개키를 이용해 복호화한다
- 7: 성공한다면 인증서가 CA의 비공개키에 의해 암호화된 것을 의미하며, 이 사이트는 신뢰할  수 있다는 것으로 생각하면 된다
  - 복호화에 실패한다면 신뢰할 수 없는 사이트로 간주한다
- 이 일련의 과정을 SSL 핸드쉐이크라고 하며, 그 과정은...
  - [쉬운 설명](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)
  - [세세한 설명](https://12bme.tistory.com/80)
  - [위키](https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake)

#### SSL 동작방법
- 공개키 암호 방식은 알고리즘 계산방식이 느린 경향이 있다
- 따라서 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키 암호화 방식을 혼합하여 사용한다
- 안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해서 임시의 무작위 대칭키를 생성 및 교환한다. 해당 대칭키는 나머지 데이터 암호화에 활용한다


> - 실제 데이터 암호화 방식: 대칭키
> - 상기 대칭키를 서로 공유하기 위한 암호화 방식: 공개키

### Reference
- https://blog.naver.com/chodahi/221406393028

# 개발공부
## Serialize와 json의 상관관계
### Serialization(직렬화)
>  컴퓨터 과학의 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 동일하거나 다른 컴퓨터 환경에 저장(이를테면 파일이나 메모리 버퍼에서, 또는 네트워크 연결 링크 간 전송)하고 나중에 재구성할 수 있는 포맷으로 변환하는 과정이다.
> 
> 오브젝트를 직렬화하는 과정은 오브젝트를 **마샬링**한다고도 한다. 반대로, 일련의 바이트로부터 데이터 구조를 추출하는 일은 역직렬화(deserialization)라고 한다.

### Marshalling (마샬링)
> 한 객체의 메모리에서 표현방식을 저장 또는 전송에 적합한 다른 데이터 형식으로 변환하는 과정이다. 또한 이는 데이터를 컴퓨터 프로그램의 서로 다른 부분 간에 혹은 한 프로그램에서 다른 프로그램으로 이동해야 할 때도 사용된다. 
> 
> 마셜링은 **직렬화**와 유사하며 한 오브젝트, 여기서는 직렬화 된 오브젝트로 멀리 떨어진 오브젝트와 통신하기 위해 사용된다.


### 둘의 차이
딱히 명확하게 나뉘어서 정의되어있진 않다. 서로 거의 동일한 의미로 사용된다.

직렬화는 마샬링에 포함된다. 마샬링이 조금 더 넓은 의미의 개념.

알게된 마샬링의 특징은 다음과 같다
- 마샬링은 코드 베이스를 기록한다.
  - 여기서 코드 베이스를 메타 데이터라고 표현하기도한다.
- managed data을 managed data로 변환하는 과정이다.
  - 이 때문에 다른 언어, 다른 플랫폼에서도 데이터를 주고받을 수 있다고 한다.

위의 정보로 미루어 보아, 마샬링은 직렬화와 다르게 그 객체의 메타 데이터(코드 베이스, 내가 이해하기론 스키마라고도 표현할 수 있겠다)도 포함된다는 의미인 것 같다.

직렬화 같은 경우는 역질렬화 하는(데이터를 받는)쪽에서도 클래스에 대한 데이터를 가지고 있어야 한다. 이 클래스가 코드  베이스라고 불리는 것과 일맥상통한 것 같다.

managed data에서 unmanaged data로 변환된다는 것도 클래스라는 정해진, 혹은 관리되는(맴버 변수의 타입이라거나, 동작들) 데이터에서 관리되지 않는 데이터(이를테면 Json) 같은 형태로 변환되는 과정인 것 같다.

다른 언어, 플랫폼에서도 사용할 수 있는 이유도,이런 메타 데이터를 포함하기 때문이 아닐까



### Serialize와 json의 상관관계
다시 주제로 돌아와서 굳이 둘의 관계를 따져본다면, 객체를 Serialize하는데 있어 Json의 형태를 취할 수 있다는 것이다.

구체적으로 들어가면 사실 직렬화는 객체를 바이트 형태의 스트림으로 변환하는 것이지만, 사실상 여기선 직렬화보다 마샬링이 더 어울리지 않을까싶다. 아까 말했던대로 명확하게 나뉜 개념이 아니라 두루뭉술하게 쓰이고 있으므로 딱히 상관은 없어보인다.

### Reference
- https://woowabros.github.io/experience/2017/10/17/java-serialize.html
- https://velog.io/@agugu95/Marshalling%EA%B3%BC-Serialization%EC%9D%98-%EC%B0%A8%EC%9D%B4
- https://taeksumart.tistory.com/3
- https://ko.wikipedia.org/wiki/%EC%BD%94%EB%93%9C%EB%B2%A0%EC%9D%B4%EC%8A%A4
- https://medium.com/@nicegirl/marshalling-vs-serialized-252caf70ba9b

## 앝은 복사와 깊은복사
1. 얕은 복사(Shallow Copy)
- 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다. 
- 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
- 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.

2. 깊은 복사(Deep Copy)
- 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
- 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다.

### `clone()`과 `Cloneable`
 `clone()`을 사용할 때는 주의해야한다.
- `Cloneable` 인터페이스는 `Object`의 `clone()`의 동작 방식을 결정한다
  - 구현(impleament)되어 있으면 `CloneNotSupportedException`를 발생시키고, 아니면 맴버 변수를 복사한 새 객체를 반환한다.

이때 주소값을 복사하기 때문에 primitive 타입 변수나 불변 객체라면 상관 없지만, 가변 객체라면 의도한대로 동작하지 않을 수 있다. 같은 주소를 참조하고 있기 때문에 어느 한쪽에서 변경된다면 복사된 모든 객체들에게 적용된다.

- https://rok93.tistory.com/entry/%EC%96%95%EC%9D%80%EB%B3%B5%EC%82%AC-VS-%EA%B9%8A%EC%9D%80%EB%B3%B5%EC%82%AC
- Effective java item 13.
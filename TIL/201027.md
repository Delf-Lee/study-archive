# 알고리즘
## 조이스틱
[(문제 링크)](https://programmers.co.kr/learn/courses/30/lessons/42860)

[(내 풀이)](https://programmers.co.kr/learn/courses/30/lessons/42860/solution_groups?language=java&type=my)

### 기존 풀이 수정 실패
알고리즘은 풀고나면 왜 이렇게 고생했나 허무해진다. 저번 풀이에서 마지막 테스트 케이스를 통과하지 못했고, 다시 점검해보았지만 내 로직에 문제는 없어보였다. 

같은 로직으로 다른 사람이 푼 C++ 코드는 통과했는데말이다(아마 완벽히 같지 않겠지 컴퓨터는 거짓말을 하지 않으니...ㅎㅎ).

### 문제에 문제가 있다
애초에 이 문제는 테스트 케이스가 완벽하지 않은 문제가 있는 듯 하다. 떄문에 잘못된 풀이 방법도 정답처리가 되고 있는 상황.

대표적인 반례가 `BBBBAAAABA(12)`와 `CANAAAAANAN(48)`

결론적으론 무조건 “**그 순간 최선**”이 “**전체적인 최선**”이 아니라는 것이다.

이 문제는 탐욕법(greedy)으로 분류되어 있는데 잘못된 것 같다.

### Greedy 알고리즘

> Greedy는
탐욕스러운 선택 조건(Greedy choice property)
최적 부분 구조 조건(Optimal Substructure)
위의 조건이 성립되어야 잘 작동한다.
> 
> **탐욕스러운 선택 조건 (Greedy choice property)**
앞의 선택이 이후의 선택에 영향을 주지 않는 조건.
>
> **최적 부분 구조 조건(Optimal Substructure)**
문제에 대한 최종 해결 방법이 부분 문제에 대해서도 또한 최적 문제 해결 방법이다는 조건.
>
> [동적 계획법(Dynamic Programming)과 탐욕법(Greedy Algorithm) - cyranocoding](https://velog.io/@cyranocoding/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming%EA%B3%BC-%ED%83%90%EC%9A%95%EB%B2%95Greedy-Algorithm-3yjyoohia5)

### 풀이 고찰
고찰이랄 것도 없지만...

처음에는 중간에 방향 전환이 가능하다는 것 자체를 생각하지 못하고 가장 가까이에 있는 A의 개수로만 방향을 정하고 계산했다. 

(이 풀이로도 테스트 케이스 하느를 제외하고 전부 정답이었다는 점에서 문제가 있는 것 같다)

두번쨰 풀이는 탐욕법으로 접근했다. A가 아닌 문자열을 만날 떄 A로 바꿔주고(카운팅), 거기를 기준으로 좌우 중 더 짧은 쪽을 선택하는

순간의 최적이 전체의 최적이 아닌 반례를 찾은 순간, 모든게 의미없는 짓이라는 걸 꺠닫게 되었다. 조건 불문 A가 아닌 문자열에서 (재귀를 이용하여) 좌우 다 계산해보고 더 작은 값을 골라냈다.

결국에는 통과했지만 찝찝하다.

### 다른 사람의 풀이
가장 상단에 있는 풀이가 재귀를 이용하지 않은 방법인데... 풀이를 봐도 이해가 가질 않는다... 왜 되는거지?

``` java
 public int solution(String name) {
        int answer = 0;
        int[] diff={0,1,2,3,4,5,6,7,8,9,10,11,12,13,12,11,10,9,8,7,6,5,4,3,2,1};
        for(char c:name.toCharArray())
            answer+=diff[c-'A'];

        int length=name.length();
        int min=length-1;

        for(int i=0;i<length;i++){
            int next=i+1;
            while(next<length && name.charAt(next)=='A'){
                next++;
            }                
            min=Math.min(min,i+length-next+Math.min(i,length-next));
        }

        return answer+min;
    }
```
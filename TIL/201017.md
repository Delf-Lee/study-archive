# 알고리즘 풀이
## N으로 표현
[(문제 링크)](https://programmers.co.kr/learn/courses/30/lessons/42895)

임의의 숫자 n과 num이 주어졌을 때,
n과 사칙연산으로 num을 만들 수 있는 조건 중 사용한 숫자의 최솟값을 구하는 문제다.

### 동적 계획법
동적 계획법 (Dynamic programming, 이하 DP) 유형에 약한 것 같아 풀어보았다. 개인적인 체감으로는 출제 빈도는 높지 않아보이지만, 난이도가 높다고 생각한다. 

DP는 사실 그리디 알고리즘과 맥락은 같다고 생각한다. 차이가 있다면, DP는 중간 결과를 저장하여 다음 결과를 구하는데 사용하고, 이런 값들을 이용해 최종 결과를 구한다는 점. 이는 **메모리** 자원을 더 소모하긴 하지만 **컴퓨팅** 자원을 효율적으로 사용해서 결과적으로 문제를 더 빠르게 풀어나갈 수 있다.

위키에는 다음과 같이 설명한다.

> 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다. 이것은 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간 내에 풀 때 사용한다.

복잡한 문제를 간단한 여러 문제로 나누어 해결한다... 알고 있던 것과 비슷하다. 

다만 문제는 그 '간단한 여러 문제'로 나누기가 어렵다는 것이다.

### 풀이

고민하다가 결국 답을 참고했다. 이런 문제를 풀떄 공통적인 감상은 *'아니 경우의 수가 너무 많은데...?'* 라는 생각이 든다는 것이다. 대게 이런 생각이 들면 DP문제라고 봐도 되지 않을까...

DP라는 개념을 알고나서는 공통점을 찾아 문제를 나누려고하지만 쉽지 않았다. 그냥 문제 이해를 못한걸지도...

---
사용할 수 있는 n의 갯수가 최대 8개라는 점을 감안해서, n을 1~8개 써서 만들 수 있는 숫자의 집합을 만드는 것이 최종 목표다. 이 집합들을 만드는데 이전에 사용했던 값들을 이용한다.

n을 i번 이용해서 만들 수 있는 숫자의 집합을 U(1)이라 하자.

U(1)의 구성은 다음과 같다
> n

U(2)의 구성은 어떨까
> nn, n+n, n-n, n*n, n/n

U(3)은 어떤 요소가 올 수 있을까
> nnn,
> (n+n)+n, (n+n)-n, (n+n)*n, (n+n)/n,
> n+(n+n), n-(n+n), n*(n+n), n/(n+n)

참고로 위에서 적은건 구성이 아니라 구성 **후보**이다. 저 중에는 연산 결과가 중복되는 요소가 있을 것이다. 그래서 집합을 쓰는 것이다. (덧붙여 연산 불가능한 수도 제외시켜 줘야한다)

여튼 무엇을 말하고 싶은지 알겠는가?

결국 U(i)의 구성 후보는 
> { n으로 만든 i자리 수, 
> U(1)과 U(n-1)의 사칙 연산으로 만들 수 있는 수,
> U(2)과 U(n-2)의 사칙 연산으로 만들 수 있는 수,
> ...
> U(n-1)과 U(1)의 사칙 연산으로 만들 수 있는 수,
> }

이다. 아까 말했던대로 중복과 연산불가한 요소는 제외시켜줘야한다. 중복은 집합의 특성상 자연스럽게 제거될테니 연산이 불가능한(0으로 나누는) 경우를 제외하면 될 것이다.

이렇게 8번 반복하면 목표해떤 집합들이 완성된다.

이제 U(1)~U(8)의 집합들을 순회하면서 num이 있는지 체크하면 될 것이다.

[자세한 풀이](https://github.com/WeareSoft/algorithm-study/blob/master/src/delf/programmers/Solution42895.java)는 다른 레포에 기록해 두었다.

# 개발 공부
## Inner Join과 Outer Join
### Join
조인은 두개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법이다. 검색하고 싶은 컬럼이 다른 테이블에 있을 경우 주로 사용하며, 여러개의 테이블을 마치 하나의 테이블인 것처럼 검색할 수 있다.

보통 조건에 해당하는 Primary key혹은 Foreign key로 두 테이블을 연결한다. 때문에 적어도 하나의 칼럼은 서로 공유되고 있어야한다.

이런 조인에는 여러가지 방법이 있다. inner, outer(left outer, right outer) full, cross, self 등등...

여기서 대표적으로 많이 쓰이는 inner와 outer join에 대해서 한번 알아보자.

### Inner Join
쉽게 말하면 주어진 조건의 테이블의 교집합에 해당하는 부분이 결과로 나온다. 다른 말로는 두 테이블이 갖고 있는 모두 갖고 있는 데이터를 보여준다고 할 수 있다.

``` sql
--문법--
SELECT
테이블별칭.조회할칼럼,
테이블별칭.조회할칼럼
FROM 기준테이블 별칭
INNER JOIN 조인테이블 별칭 ON 기준테이블별칭.기준키 = 조인테이블별칭.기준키....

--예제--
SELECT
A.NAME, --A테이블의 NAME조회
B.AGE --B테이블의 AGE조회
FROM EX_TABLE A
INNER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP AND A.DEPT = B.DEPT
```

### Outer Join
Inner Join이 공통된 부분을 보여주는 교집합에 해당했다면, Outer join은 반대로 합집합에 해당하는 부분이 결과로 나온다. 

조인하는 여러 테이블에서 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽 테이블의 내용을 전부 출력하는 방법이다. 즉, 조인 조건에 만족하지 않아도 해당 행을 출력하고 싶을 때 사용할 수 있다.

이는 어떤 테이블을 기준으로 하느냐에 따라서 세가지로 나뉜다.
- Left Outer Join
- Right Outer Join
- Full Outer Join


#### Left Outer Join
왼쪽 테이블 즉, **기준 테이블**의 데이터를 전부 가져와, 조인 테이블에서 조건에 맞는 데이터를 매칭시켜 보여준다. 데이터가 없는 경우에는 `NULL`로 표시된다.
``` sql
--문법--
SELECT 테이블별칭.조회할칼럼, 테이블별칭.조회할칼럼
FROM 기준테이블 별칭
LEFT OUTER JOIN 조인테이블 별칭 ON 기준테이블별칭.기준키 = 조인테이블별칭.기준키 .....

--예제--
SELECT A.NAME, B.AGE
FROM EX_TABLE A
LEFT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP AND A.DEPT = B.DEPT
```
#### Right Outer Join
반대로 오른쪽 테이블, **조인 테이블**의 데이터를 전부 가져와. 기준 테이블에서 조건에 맞는 데이터를 매칭시켜 보여준다. 역시 데이터가 없는 경우에는 `NULL`로 표시된다.

``` sql
--문법--
SELECT 테이블별칭.조회할칼럼, 테이블별칭.조회할칼럼
FROM 기준테이블 별칭
RIGHT OUTER JOIN 조인테이블 별칭 ON 기준테이블별칭.기준키 = 조인테이블별칭.기준키 .....

--예제--
SELECT A.NAME, B.AGE
FROM EX_TABLE A
RIGHT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP AND A.DEPT = B.DEPT
```

#### Full Outer
위의 두 조인을 합친 경우. 말 그대로의 합집합에 해당하는 자료를 보여준다.

``` sql
--문법--
SELECT 테이블별칭.조회할칼럼, 테이블별칭.조회할칼럼
FROM 기준테이블 별칭
FULL OUTER JOIN 조인테이블 별칭 ON 기준테이블별칭.기준키 = 조인테이블별칭.기준키 .....

--예제--
SELECT A.NAME, B.AGE 
FROM EX_TABLE A
FULL OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP AND A.DEPT = B.DEPT
```

### 정리

설명할 때, '어느 쪽' 데이터를 기준으로 삼는지에 대한 표현이 설명하기 좋은 것 같다.
> 왼쪽 테이블 즉, **기준 테이블**의 데이터를 전부 가져와, 조인 테이블에서 조건에 맞는 데이터를 매칭시켜 보여준다. 데이터가 없는 경우에는 `NULL`로 표시된다.


### Reference
- https://coding-factory.tistory.com/87
- https://futurists.tistory.com/17
- https://jhkang-tech.tistory.com/55


## 쿠키와 세션
면접에서 곧잘 나오는 질문이다. 둘을 묶은 이유는 관련이 있기 때문이겠지. 기본적으로 둘의 공통점과 차이점을 알아두면 될 것 같다.

일단 둘은 웹 서버와 클라이언트가 통신할 때, 클라이언트의 정보를 캐싱해둬서 효율적으로 통신하기 위한 기술이다.

### HTTP 프로토콜의 특징
HTTP 프로토콜은 Connectionless(비연결지향), Stateless(상태 없음)이라는 특징이 있다.
- Connectionless(비연결지향)
  - 클라이언트가 서버에 요청(Request)을 했을 때, 그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식
  - HTTP 1.1 버전에서 연결을 유지하고, 재활용 하는 기능이 Default 로 추가
  - keep-alive 값으로 변경 가능
- Stateless(상태 없음)
  - 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식
  - 클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도, 두번째 통신에서 이전 데이터를 유지하지 않음

이런 특성 때문에 웹이 무한한 범용성을 갖게 되었지만, 그냥 문서 열람 수준에서 끝나는게 아닌 실제로 여러가지 다양한 서비스가 개발되면서 제한이 되어버렸다.

### 쿠키
**클라이언트** 쪽에서 캐싱하고 있는 key-value 형식의 데이터로, 서버에게 요청할 때 이를 포함하여 전송한다.
- 쿠키의 구성 요소
  - 이름: 각각의 쿠키를 구별하는 데 사용되는 이름
  - 값: 쿠키의 이름과 관련된 값
  - 유효시간: 쿠키의 유지시간
  - 도메인: 쿠키를 전송할 도메인
  - 경로: 쿠키를 전송할 요청 경로

- 쿠키의 동작 순서
  - 클라이언트가 페이지를 요청
  - 서버에서 쿠키를 생성
  - HTTP 헤더에 쿠키를 포함 시켜 응답
  - 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
  - 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
  - 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

- 쿠키의 사용 예
  - 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
  - 쇼핑몰의 장바구니 기능
  - 자동 로그인
  - 팝업창 여부 설정 저장

### 세션
**서버** 쪽에서 캐싱하고 있는 **쿠키**.

### 차이점
#### 저장 위치
쿠키는 클라이언트에, 세션은 서버에 저장된다.
#### 속도/성능
쿠키에 정보가 있기 때문에 쿠키에 정보가 있기 때문에 서버에 요청시 헤더를 바로 참조하면 되므로 속도에서 유리하지만, 세션은 제공받은 세션아이디(Key)를 이용해서 서버에서 다시 데이터를 참조해야하므로 속도가 비교적 느릴 수 있다.
#### 보안 
쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋다.
#### 라이프 사이클
쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.


### Referenc
- https://interconnection.tistory.com/74
- https://jeong-pro.tistory.com/80
- https://hahahoho5915.tistory.com/32
- https://rongscodinghistory.tistory.com/3

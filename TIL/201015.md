# 알고리즘 풀이
## 삼각 달팽이
[링크](https://programmers.co.kr/learn/courses/30/lessons/68645)

피라미드라던가, 달팽이 모양이라던가 등등의 배열을 순회하는 방법에 대한 문제인 것 같다. 문제의 규칙성을 찾고 맞게(인덱스의 범위를 벗어나지 않는 등) 조건대로 순회하는게 관건.

내 풀이의 핵심은 다음과 같다.
> - n*n 2차원 배열에서
> - 아래(남), 오른쪽(동), 대각선(북서) 순으로 숫자를 채워 넣는다
> - 채워넣는 숫자의 양은 각 방향마다 하나 씩 줄어든다
> - 2차원 배열에서 내용이 있는 것만 선별해 1차원 배열로 생성한다

다 풀고 다른 사람의 풀이를 보니 배열을 이용하는 방법은 비슷했다.

가장 상위에 있던 문제가 신기했는데, 숫자가 3을 나눈 나머지 기준으로 각 행과 열의 증분이 달라지는 규칙을 이용한 풀이법이었다. 감탄... 이건 적어도 '(내) 눈에 보이지 않는' 규칙이다.

``` java
if (i % 3 == 0) {
    ++x;
} else if (i % 3 == 1) {
    ++y;
} else if (i % 3 == 2) {
    --x;
    --y;
}
matrix[x][y] = num++;
```

## 13 구하기
온코더에서 새로 '챌린지'라고 분률되어 있는 문제 모음을 풀어보았다. 단계가 해금되는 방식이라 왠지 승부욕이 생기는 것 같은 느낌...

[문제 링크](https://www.oncoder.com/ground/HJok8E6RX)

숫자를, 그중 자릿수를 다루는 유형 중 하나인 것 같다.

1부터 n까지 숫자 중 13이 들어가는 숫자가 몇 개인지 카운팅하는 문제인데, 생각나는 직관적인 풀이는 문자열로 바꿔서 "13"이라는 문자열이 있는지 체크하는 방법을 떠올렸지만, 문자열보다 숫자 자체를 다루는게 더 효율적일 것 같아서 나머지를 이용하는 방법을 사용했다.

간단하게 말하면 임의의 숫자를 10으로 나눠가면서 13으로 끝나는지 체크했다.

처음에 13이 들어가는 숫자를 세야되는데 13자체의 갯수를 세서 틀렸었다. 문제를 잘 읽자.


## 셀프 넘버 판별
[문제 링크](https://www.oncoder.com/ground/B12g8N6RX)

위와 동일한 유형의 문제. 풀이 방법까지 유사하다.

어떤 함수 `y=f(x)`에서 y값이 정해졌을 때, x 값이 될 수 있는 변수의 수를 구하는 문제. 여기서 함수는 `자기 자신`+`각 자리 숫자`이다. (ex. f(12) = 12 + 1 + 2 = 15)

각 자리 숫자를 구해야하기 때문에 역시 나머지를 이용하여 풀었다. 문자열로 풀었으면 더 빨랐을까?